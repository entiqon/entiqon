// Code generated by ENTIQON.
// File: internal/core/driver/dialect_base.go
// Description: Provides BaseDialect implementation of the Dialect interface.
// Since: v1.4.0

package driver

import (
	"fmt"
	"strconv"
)

// BaseDialect provides a foundational implementation of the Dialect interface.
// It can be embedded and selectively overridden by specific dialect structs.
//
// Since: v1.4.0
type BaseDialect struct {
	// name holds the dialect identifier (e.g., "postgres", "mysql").
	name string

	// quotation defines the quoting style used for identifiers.
	quotation QuotationType

	// placeholder is an optional function that generates argument placeholders (e.g., $1, ?, :name).
	placeholder func(index int) string

	// supportsUpsert indicates native UPSERT support in the dialect.
	supportsUpsert bool

	// supportsReturning indicates RETURNING clause support in the dialect.
	supportsReturning bool
}

// GetName returns the dialect name.
// If unset, "base" is returned.
//
// Updated: v1.4.0
func (b *BaseDialect) GetName() string {
	if b.name == "" {
		return "base"
	}
	return b.name
}

// QuoteType returns the configured identifier quotation style.
//
// Since: v1.4.0
func (b *BaseDialect) QuoteType() QuotationType {
	return b.quotation
}

// QuoteIdentifier returns the given identifier with dialect-appropriate quoting.
// Defaults to no quoting unless the quotation style is configured.
//
// Updated: v1.4.0
func (b *BaseDialect) QuoteIdentifier(identifier string) string {
	switch b.quotation {
	case QuoteDouble:
		return `"` + identifier + `"`
	case QuoteBacktick:
		return "`" + identifier + "`"
	case QuoteBracket:
		return "[" + identifier + "]"
	default:
		return identifier
	}
}

// QuoteLiteral returns a printable literal string for debugging/logging purposes only.
// ⚠️ DO NOT use this for building real queries — use placeholders instead.
//
// Updated: v1.4.0
func (b *BaseDialect) QuoteLiteral(value any) string {
	switch v := value.(type) {
	case string:
		return "'" + v + "'"
	case int, int64, float64:
		return fmt.Sprintf("%v", v)
	case bool:
		return strconv.FormatBool(v)
	default:
		return fmt.Sprintf("'%v'", v)
	}
}

// Placeholder returns a positional argument placeholder string.
// If a placeholder function is set, it delegates to that.
// Otherwise, returns a generic "?".
//
// Updated: v1.4.0
func (b *BaseDialect) Placeholder(index int) string {
	if b.placeholder != nil {
		return b.placeholder(index)
	}
	return "?"
}

// BuildLimitOffset returns the dialect-compatible LIMIT and OFFSET clause.
// Supports any combination of positive limit/offset values.
// Returns an empty string if neither is defined.
//
// Updated: v1.4.0
func (b *BaseDialect) BuildLimitOffset(limit, offset int) string {
	switch {
	case limit >= 0 && offset >= 0:
		return fmt.Sprintf("LIMIT %d OFFSET %d", limit, offset)
	case limit >= 0:
		return fmt.Sprintf("LIMIT %d", limit)
	case offset >= 0:
		return fmt.Sprintf("OFFSET %d", offset)
	default:
		return ""
	}
}

// RenderFrom returns a dialect-safe FROM clause expression.
// Table name is quoted; alias is not quoted.
//
// Example: `"users" u`, `\`orders\` o`, `[logs] l`
//
// Updated: v1.4.0
func (b *BaseDialect) RenderFrom(table string, alias string) string {
	if alias != "" {
		return fmt.Sprintf("%s %s", b.QuoteIdentifier(table), alias)
	}
	return b.QuoteIdentifier(table)
}

// SupportsUpsert returns whether the dialect supports native upsert syntax.
//
// Updated: v1.4.0
func (b *BaseDialect) SupportsUpsert() bool {
	return b.supportsUpsert
}

// SupportsReturning returns whether the dialect supports RETURNING clauses.
//
// Updated: v1.4.0
func (b *BaseDialect) SupportsReturning() bool {
	return b.supportsReturning
}
