// Code generated by ENTIQON.
// File: db/driver/base.go
// Description: Provides BaseDialect implementation of the Dialect interface.
// Since: v1.4.0

package driver

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/entiqon/db/driver/styling"
)

// BaseDialect provides a foundational implementation of the Dialect interface.
// It can be embedded and selectively overridden by specific dialect structs.
//
// Since: v1.4.0
type BaseDialect struct {
	// EnableAliasing indicates whether the dialect supports table aliases
	// in clauses such as DELETE FROM, UPDATE FROM, or SELECT FROM.
	//
	// When true, builders will include alias expressions using RenderFrom.
	//
	// Since: v1.4.0
	EnableAliasing bool

	// EnableReturning specifies whether the dialect supports SQL RETURNING clauses,
	// such as `INSERT ... RETURNING id` or `UPDATE ... RETURNING *`.
	//
	// This flag is evaluated by the SupportsReturning method.
	// Commonly enabled in dialects like PostgreSQL.
	//
	// Since: v1.4.0
	EnableReturning bool

	// EnableUpsert specifies whether the dialect supports native UPSERT syntax,
	// such as `INSERT ... ON CONFLICT DO UPDATE` or `INSERT ... ON DUPLICATE KEY UPDATE`.
	//
	// This flag is evaluated by the SupportsUpsert method.
	// Typically enabled in PostgreSQL and MySQL dialects.
	//
	// Since: v1.4.0
	EnableUpsert bool

	// Name holds the dialect identifier (e.g., "postgres", "mysql").
	Name string

	// QuoteStyle defines the quoting style used for identifiers.
	QuoteStyle styling.QuoteStyle

	// PlaceholderStyle is an optional function that generates argument placeholders (e.g., $1, ?, :GetName).
	PlaceholderStyle styling.PlaceholderStyle

	counter int // used for sequential placeholder tracking
}

// GetName returns the dialect Name.
// If unset, "base" is returned.
//
// Updated: v1.4.0
func (b *BaseDialect) GetName() string {
	if b.Name == "" {
		return "base"
	}
	return b.Name
}

// NextPlaceholder returns the next sequential placeholder for the dialect.
// For example: $1, $2 for Postgres or ? for MySQL.
//
// Since: v1.6.0
func (b *BaseDialect) NextPlaceholder() string {
	b.counter++
	return b.Placeholder(b.counter)
}

// QuoteType returns the configured identifier QuoteStyle style.
//
// Since: v1.4.0
func (b *BaseDialect) QuoteType() styling.QuoteStyle {
	return b.QuoteStyle
}

// QuoteIdentifier returns the given identifier with dialect-appropriate quoting.
// Defaults to no quoting unless the QuoteStyle style is configured.
//
// Updated: v1.4.0
func (b *BaseDialect) QuoteIdentifier(identifier string) string {
	return b.QuoteStyle.Quote(identifier)
}

// QuoteLiteral returns a printable literal string for debugging/logging purposes only.
// ⚠️ DO NOT use this for building real queries — use placeholders instead.
//
// Updated: v1.4.0
func (b *BaseDialect) QuoteLiteral(value any) string {
	switch v := value.(type) {
	case string:
		return "'" + v + "'"
	case int, int64, float64:
		return fmt.Sprintf("%v", v)
	case bool:
		return strconv.FormatBool(v)
	default:
		return fmt.Sprintf("'%v'", v)
	}
}

// Placeholder returns a positional argument placeholder string.
// If a placeholder function is set, it delegates to that.
// Otherwise, returns a generic "?".
//
// Updated: v1.4.0
func (b *BaseDialect) Placeholder(index int) string {
	return b.PlaceholderStyle.Format(index)
}

// PlaceholderNamed returns a name argument placeholder string.
// If a placeholder function is set, it delegates to that.
// Otherwise, returns a generic "?".
//
// Updated: v1.6.0
func (b *BaseDialect) PlaceholderNamed(name string) string {
	return b.PlaceholderStyle.FormatNamed(name)
}

// BuildLimitOffset returns the dialect-compatible LIMIT and OFFSET clause.
// Supports any combination of positive limit/offset values.
// Returns an empty string if neither is defined.
//
// Updated: v1.4.0
func (b *BaseDialect) BuildLimitOffset(limit, offset int) string {
	switch {
	case limit >= 0 && offset >= 0:
		return fmt.Sprintf("LIMIT %d OFFSET %d", limit, offset)
	case limit >= 0:
		return fmt.Sprintf("LIMIT %d", limit)
	case offset >= 0:
		return fmt.Sprintf("OFFSET %d", offset)
	default:
		return ""
	}
}

// RenderFrom returns a dialect-safe FROM clause expression.
// Table Name is quoted; alias is not quoted.
//
// Example: `"users" u`, `\`orders\` o`, `[logs] l`
//
// Updated: v1.4.0
func (b *BaseDialect) RenderFrom(table string, alias string) string {
	quoted := b.QuoteIdentifier(table)
	if alias != "" && b.EnableAliasing {
		return fmt.Sprintf("%s %s", quoted, alias)
	}
	return quoted
}

// ResetPlaceholders resets the internal placeholder counter.
// Should be called before rendering each new SQL statement.
//
// Since: v1.6.0
func (b *BaseDialect) ResetPlaceholders() {
	b.counter = 0
}

// SupportsReturning returns true if the dialect supports RETURNING clauses.
//
// This delegates to the EnableReturning field in BaseDialect, but may be overridden
// in custom dialect implementations to enforce computed behavior.
//
// Since: v1.4.0
func (b *BaseDialect) SupportsReturning() bool {
	return b.EnableReturning
}

// SupportsUpsert returns true if the dialect supports native UPSERT syntax.
//
// This default implementation reads the EnableUpsert field in BaseDialect.
// Custom dialects may override this method to implement dynamic or computed support.
//
// Since: v1.4.0
func (b *BaseDialect) SupportsUpsert() bool {
	return b.EnableUpsert
}

// Validate ensures the BaseDialect is correctly configured.
//
// A dialect is considered valid if:
//   - PlaceholderStyle is set to a non-empty value
//   - Name is not empty or whitespace
//
// The QuoteStyle style is allowed to be QuoteNone if the dialect does not require identifier quoting.
//
// Returns:
//   - nil if the dialect is valid
//   - an error if the configuration is incomplete or invalid
//
// Since: v1.4.0
func (b *BaseDialect) Validate() error {
	if strings.TrimSpace(b.Name) == "" {
		return fmt.Errorf("BaseDialect: dialect is not configured")
	}
	if !b.PlaceholderStyle.IsValid() {
		return fmt.Errorf("BaseDialect: placeholder style is not configured")
	}
	if !b.QuoteStyle.IsValid() {
		return fmt.Errorf("BaseDialect: quote style is not configured")
	}
	//if b.EnableAliasing {
	//	if !b.TableAliasStyle.IsValid() {
	//		return fmt.Errorf("BaseDialect: table alias style is invalid")
	//	}
	//	if !b.ColumnAliasStyle.IsValid() {
	//		return fmt.Errorf("BaseDialect: column alias style is invalid")
	//	}
	//}
	return nil
}
