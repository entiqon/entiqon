// Code generated by ENTIQON.
// File: db/internal/build/token/column_test.go
// Description: Defines a minimal SQL Condition structure for use in builders.
// Since: v1.6.0

package token_test

import (
	"fmt"
	"strings"
	"testing"

	"github.com/entiqon/entiqon/db/driver"
	token2 "github.com/entiqon/entiqon/db/internal/build/token"
)

func TestColumn(t *testing.T) {
	t.Run("Usage", func(t *testing.T) {
		t.Run("Basic", func(t *testing.T) {
			col := token2.NewColumn("id")
			if col.GetName() != "id" {
				t.Errorf("expected column name 'id', got %q", col.GetName())
			}
			if col.IsAliased() {
				t.Errorf("expected column to not be aliased")
			}
			if col.IsQualified() {
				t.Errorf("expected column to not be qualified")
			}
			if !col.IsValid() {
				t.Errorf("expected column to be valid")
			}
		})

		t.Run("InlineTable", func(t *testing.T) {
			col := token2.NewColumn("users.id")
			if got := col.GetQualified(); got != "users" {
				t.Errorf("expected column qualified name to be 'users': %v", col.GetQualified())
			}
		})

		t.Run("AliasMatch", func(t *testing.T) {
			col := token2.NewColumn("id AS uid", "uid")
			if alias := col.GetAlias(); alias != "uid" {
				t.Errorf("expected column alias to be 'uid', got %q'", alias)
			}
		})

		t.Run("AliasConflict", func(t *testing.T) {
			col := token2.NewColumn("user_id AS internal", "external")
			if col.IsValid() {
				t.Fatalf("expected column to be invalid due to alias conflict")
			}
			if col.GetError() == nil {
				t.Fatalf("expected error due to alias conflict, got nil")
			}
			if !strings.Contains(col.GetError().Error(), "alias conflict") {
				t.Errorf("expected error message to contain 'alias conflict', got: %v", col.GetError())
			}
			if col.GetName() != "user_id" {
				t.Errorf("expected column name 'user_id', got %q", col.GetName())
			}
			if col.GetAlias() != "external" {
				t.Errorf("expected alias 'external', got %q", col.GetAlias())
			}
			if col.GetInput() != "user_id AS internal" {
				t.Errorf("expected source 'user_id AS internal', got %q", col.GetInput())
			}
		})

		t.Run("InlineAlias", func(t *testing.T) {
			col := token2.NewColumn("id AS email")
			if col.GetName() != "id" {
				t.Errorf("expected column name 'id', got %q", col.GetName())
			}
			if col.GetAlias() != "email" {
				t.Errorf("expected alias 'email', got %q", col.GetAlias())
			}
		})

		t.Run("ExplicitAlias", func(t *testing.T) {
			col := token2.NewColumn("id", "email")
			if col.GetName() != "id" {
				t.Errorf("expected column name 'id', got %q", col.GetName())
			}
			if col.GetAlias() != "email" {
				t.Errorf("expected alias 'email', got %q", col.GetAlias())
			}
		})

		t.Run("ParsingErrors", func(t *testing.T) {
			t.Run("StartsWithAS", func(t *testing.T) {
				col := token2.NewColumn("AS email")
				if col.IsValid() {
					t.Fatalf("expected column to be invalid due to starting with 'AS'")
				}
				if col.GetError() == nil || !strings.Contains(col.GetError().Error(), "cannot start with 'AS'") {
					t.Errorf("expected error containing 'cannot start with 'AS'', got: %v", col.GetError())
				}
				if col.GetInput() != "AS email" {
					t.Errorf("expected source to be 'AS email', got %q", col.GetInput())
				}
			})

			t.Run("OnlyAlias", func(t *testing.T) {
				col := token2.NewColumn(" AS alias")
				if col.IsValid() {
					t.Fatalf("expected column to be invalid due to starting with 'AS'")
				}
				if col.GetError() == nil || !strings.Contains(col.GetError().Error(), "cannot start with 'AS'") {
					t.Errorf("expected error containing 'cannot start with 'AS'', got: %v", col.GetError())
				}
				if col.GetInput() != " AS alias" {
					t.Errorf("expected source to be ' AS alias', got %q", col.GetInput())
				}
			})

			t.Run("DotWithoutColumn", func(t *testing.T) {
				col := token2.NewColumn("u.")
				if col.IsValid() {
					t.Fatalf("expected column to be invalid due to missing column name after dot")
				}
				if col.GetError() == nil || !strings.Contains(col.GetError().Error(), "column name is required") {
					t.Errorf("expected error containing 'column name is required', got: %v", col.GetError())
				}
				if col.GetInput() != "u." {
					t.Errorf("expected source to be 'u.', got %q", col.GetInput())
				}
			})
		})

		t.Run("Invalid", func(t *testing.T) {
			col := token2.NewColumn("id, uid")
			if col.IsValid() {
				t.Errorf("expected column to be invalid due to comma-separated input")
			}
			if col.GetError() == nil {
				t.Errorf("expected error due to comma-separated alias, got nil")
			} else if !strings.Contains(col.GetError().Error(), "aliases must not be comma-separated") {
				t.Errorf(
					"unexpected error message: got %q, want message containing %q",
					col.GetError().Error(),
					"aliases must not be comma-separated",
				)
			}
		})
	})

	t.Run("Members", func(t *testing.T) {
		t.Run("GetQualified", func(t *testing.T) {
			t.Run("WithNilReceiver", func(t *testing.T) {
				var column *token2.Column = nil
				if got := column.GetQualified(); got != "" {
					t.Errorf("expected '' error, got %v", got)
				}
			})

			t.Run("NotQualified", func(t *testing.T) {
				column := token2.NewColumn("id")
				if got := column.GetQualified(); got != "" {
					t.Errorf("expected '' error, got %v", got)
				}
			})

			t.Run("Inline", func(t *testing.T) {
				column := token2.NewColumn("users.id")
				if got := column.GetQualified(); got != "users" {
					t.Errorf("expected 'users' error, got %v", got)
				}
			})

			t.Run("WithTable", func(t *testing.T) {
				column := token2.NewColumn("id").WithTable(token2.NewTable("users"))
				if got := column.GetQualified(); got != "users" {
					t.Errorf("expected 'users' error, got %v", got)
				}
			})

			t.Run("WithAliasedTable", func(t *testing.T) {
				column := token2.NewColumn("id").WithTable(token2.NewTable("users", "u"))
				if got := column.GetQualified(); got != "u" {
					t.Errorf("expected 'u' error, got %v", got)
				}
			})

			t.Run("Conflict", func(t *testing.T) {
				column := token2.NewColumn("users.id").WithTable(token2.NewTable("user", "u"))
				if !strings.Contains(column.GetError().Error(), "table mismatch") {
					t.Errorf("expected table mismatch error, got %v", column.GetError())
				}
			})
		})

		t.Run("IsQualified", func(t *testing.T) {
			t.Run("WithNilReceiver", func(t *testing.T) {
				var column *token2.Column = nil
				if got := column.IsQualified(); got != false {
					t.Errorf("expected false, got %v", got)
				}
			})

			t.Run("NotQualified", func(t *testing.T) {
				column := token2.NewColumn("id")
				if got := column.IsQualified(); got != false {
					t.Errorf("expected false, got %v", got)
				}
			})

			t.Run("Inline", func(t *testing.T) {
				column := token2.NewColumn("users.id")
				if got := column.IsQualified(); got != true {
					t.Errorf("expected true, got %v", got)
				}
			})

			t.Run("WithTable", func(t *testing.T) {
				column := token2.NewColumn("id").WithTable(token2.NewTable("users"))
				if got := column.IsQualified(); got != true {
					t.Errorf("expected true, got %v", got)
				}
			})

			t.Run("WithAliasedTable", func(t *testing.T) {
				column := token2.NewColumn("id").WithTable(token2.NewTable("users", "u"))
				if got := column.IsQualified(); got != true {
					t.Errorf("expected true, got %v", got)
				}
			})

			t.Run("Conflict", func(t *testing.T) {
				column := token2.NewColumn("users.id").WithTable(token2.NewTable("user", "u"))
				if !strings.Contains(column.GetError().Error(), "table mismatch") {
					t.Errorf("expected table mismatch error, got %v", column.GetError())
				}
			})
		})

		t.Run("GetRaw", func(t *testing.T) {
			t.Run("WithNilReceiver", func(t *testing.T) {
				var column *token2.Column = nil
				column.SetError("ignored", fmt.Errorf("structural error"))
				if got := column.GetRaw(); got != "" {
					t.Errorf("expected nil error, got %v", got)
				}
			})

			t.Run("WithName", func(t *testing.T) {
				column := token2.NewColumn("name")
				if got := column.GetRaw(); got != "name" {
					t.Errorf("expected 'name', got %q", got)
				}
			})

			t.Run("WithAlias", func(t *testing.T) {
				column := token2.NewColumn("name", "alias")
				if got := column.GetRaw(); got != "name AS alias" {
					t.Errorf("expected 'name AS alias', got %q", got)
				}
			})
		})

		t.Run("Render", func(t *testing.T) {
			postgres := driver.NewPostgresDialect()

			t.Run("Basic", func(t *testing.T) {
				col := token2.NewColumn("email")
				if got := col.Render(postgres); got != `"email"` {
					t.Errorf(`Render mismatch: got %q, want "email"`, got)
				}
			})

			t.Run("Aliased", func(t *testing.T) {
				col := token2.NewColumn("email AS user_email")
				if got := col.Render(postgres); got != `"email" AS "user_email"` {
					t.Errorf(`Render mismatch: got %q, want "email" AS "user_email"`, got)
				}
			})

			t.Run("Qualified", func(t *testing.T) {
				col := token2.NewColumn("users.email").WithTable(token2.NewTable("users"))
				got := col.Render(postgres)
				want := `"users"."email"`

				if got != want {
					t.Errorf("Render mismatch: got %q, want %q", got, want)
				}
			})

			t.Run("Full", func(t *testing.T) {
				col := token2.NewColumn("id", "uid").WithTable(token2.NewTable("users u"))
				if got := col.Render(postgres); got != `"u"."id" AS "uid"` {
					t.Errorf(`Render mismatch: got %q, want "u"."id" AS "uid"`, got)
				}
			})

			t.Run("NoTableAliased", func(t *testing.T) {
				col := token2.NewColumn("users.email AS mail").WithTable(token2.NewTable("users"))
				got := col.Render(postgres)
				want := `"users"."email" AS "mail"`

				if got != want {
					t.Errorf("Render mismatch: got %q, want %q", got, want)
				}
			})

			t.Run("InvalidColumn", func(t *testing.T) {
				col := token2.NewColumn("") // invalid
				got := col.Render(postgres)

				if got != "" {
					t.Errorf("Expected empty render for invalid column, got %q", got)
				}
			})
		})

		t.Run("SetQualified", func(t *testing.T) {
			t.Run("WithNilReceiver", func(t *testing.T) {
				var column *token2.Column = nil
				column.SetQualified("users")
				if got := column.GetQualified(); got != "" {
					t.Errorf("expected '' error, got %v", got)
				}
			})

			t.Run("Qualified", func(t *testing.T) {
				column := token2.NewColumn("id")
				column.SetQualified("users")
				if got := column.GetQualified(); got != "users" {
					t.Errorf("expected 'users' error, got %v", got)
				}
			})

			t.Run("ConflictQualified", func(t *testing.T) {
				column := token2.NewColumn("users.id")
				column.SetQualified("user")
				if got := column.GetQualified(); got != "users" {
					t.Errorf("expected 'users' error, got %v", got)
				}
				if column.GetError() == nil ||
					!strings.Contains(column.GetError().Error(), "qualified conflict") {
					t.Errorf("expected qualified conflict error, got %v", column.GetError())
				}
			})

			t.Run("ConflictWithTable", func(t *testing.T) {
				column := token2.NewColumn("id").WithTable(token2.NewTable("users"))
				column.SetQualified("user")
				if got := column.GetQualified(); got != "users" {
					t.Errorf("expected 'users' error, got %v", got)
				}
				if column.GetError() == nil ||
					!strings.Contains(column.GetError().Error(), "qualified conflict") {
					t.Errorf("expected qualified conflict error, got %v", column.GetError())
				}
			})

			t.Run("WithAliasedTable", func(t *testing.T) {
				column := token2.NewColumn("id").WithTable(token2.NewTable("users", "u"))
				column.SetQualified("user")
				if got := column.GetQualified(); got != "u" {
					t.Errorf("expected 'u' error, got %v", got)
				}
				if column.GetError() == nil ||
					!strings.Contains(column.GetError().Error(), "qualified conflict") {
					t.Errorf("expected qualified conflict error, got %v", column.GetError())
				}
			})
		})

		t.Run("String", func(t *testing.T) {
			t.Run("WithNilReceiver", func(t *testing.T) {
				var c *token2.Column
				if got := c.String(); got != "Column(nil)" {
					t.Errorf("expected 'Column(nil)', got %q", got)
				}
			})

			t.Run("Valid", func(t *testing.T) {
				col := token2.NewColumn("users.id", "uid")
				want := `Column("id") [aliased: true, qualified: true, errored: false]`
				if got := col.String(); got != want {
					t.Errorf("String mismatch: got %q, want %q", got, want)
				}
			})

			t.Run("WithError", func(t *testing.T) {
				col := token2.NewColumn("users.id").WithTable(token2.NewTable("orders"))
				if !col.HasError() {
					t.Errorf("expected column to have error due to table mismatch")
				}
				if got := col.String(); !strings.Contains(got, "table mismatch") {
					t.Errorf("expected String to contain 'table mismatch', got %q", got)
				}
			})
		})
	})

	t.Run("EdgeCases", func(t *testing.T) {
		t.Run("PostgresEmptyName", func(t *testing.T) {
			col := token2.NewColumn("'' AS name")
			if !col.IsValid() {
				t.Fatalf("expected column to be valid, but got error: %v", col.GetError())
			}
			if col.GetName() != "''" {
				t.Errorf("expected column name \"''\", got %q", col.GetName())
			}
			if col.GetAlias() != "name" {
				t.Errorf("expected alias 'name', got %q", col.GetAlias())
			}
		})
	})
}
