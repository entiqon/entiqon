// Code generated by ENTIQON.
// File: db/internal/build/token/column.go
// Description: Defines a minimal SQL Condition structure for use in builders.
// Since: v1.6.0

package token

import (
	"fmt"

	"github.com/entiqon/db/driver"
	"github.com/entiqon/db/internal/core/contract"
)

// Column represents a SQL column reference used within SELECT, WHERE, ORDER BY, and similar clauses.
//
// It supports optional table qualification (e.g., "users.id") and aliasing (e.g., "id AS user_id").
// Column embeds BaseToken to manage naming, alias resolution, and error reporting.
//
// Columns can be parsed from expressions (e.g., "users.id AS uid") or constructed programmatically.
// They are designed to work inside SQL builders where elements need to be resolved, validated, and
// rendered in a dialect-agnostic manner.
//
// # Usage
//
//	c := NewColumn("users.id AS uid")
//	fmt.Println(c.Raw())     	// "users.id"
//	fmt.Println(c.IsAliased()) 	// true
//	fmt.Println(c.String())  	// Column("users.id") [aliased: true, qualified: true]
type Column struct {
	*BaseToken

	// Table holds the attached table token used for qualification during rendering.
	// It may be inferred during parsing or explicitly set via WithTable().
	// When non-nil and valid, the column is considered qualified.
	//
	// # Example
	//
	//	c := NewColumn("id", "alias").WithTable(NewTable("users AS u"))
	//	fmt.Println(c.Raw()) // "u.alias"
	Table *Table

	// Qualified stores the parsed table prefix (if any) from the original expression,
	// such as "users" in "users.id". It is used for validation, source resolution,
	// and diagnostics — but is not rendered directly.
	//
	// # Example
	//
	//	c := NewColumn("users.id")
	//	fmt.Println(c.Qualified) // "users"
	qualified string
}

// NewColumn constructs a Column token from a raw expression and optional alias.
//
// If no alias is provided, it attempts to extract one inline using the SQL keyword "AS",
// or through space/comma separation. If both an inline alias and an explicit alias
// are provided, and they conflict, an error is stored in the token.
//
// If the expression is qualified (e.g., "users.id"), the table prefix is used
// to create a Table token automatically, which informs downstream resolution.
//
// # Examples
//
//	NewColumn("id")                    → name: "id"
//	NewColumn("id AS uid")             → name: "id", alias: "uid"
//	NewColumn("users.id")              → name: "id", table: "users"
//	NewColumn("id", "alias")           → name: "id", alias: "alias"
//	NewColumn("users.id", "alias")     → name: "id", table: "users", alias: "alias"
func NewColumn(expr string, alias ...string) *Column {
	base := NewBaseToken(expr, alias...)
	base.SetKind(contract.ColumnKind)

	// **Early exit on parse error**: preserve the original BaseToken error
	if base.IsErrored() {
		return &Column{BaseToken: base}
	}

	// Split off the table qualifier from the parsed name
	tableName, colName := ParseTableColumn(base.GetName())
	if colName == "" {
		base.SetError(expr, fmt.Errorf("column name is required"))
	} else {
		base.SetName(colName)
	}

	// Initialize qualified to whatever tableName was (empty if none)
	col := &Column{BaseToken: base, qualified: tableName}

	// If there really was a qualifier, attach the TableToken to validate it
	if tableName != "" {
		return col.WithTable(NewTable(tableName))
	}
	return col
}

// GetQualified returns the explicit qualifier for this Column (e.g. schema or table alias).
// Nil receiver → empty string.
//
// Example:
//
//	var col *Column = nil
//	fmt.Println(col.GetQualified()) // Output:
//
//	col = NewColumn("id")
//	fmt.Println(col.GetQualified()) // Output:
//
//	col.SetQualified("users")
//	fmt.Println(col.GetQualified()) // Output: users
//
// Since: v1.6.0
func (c *Column) GetQualified() string {
	if c == nil {
		return ""
	}
	return c.qualified
}

// IsQualified reports whether this Column is qualified—either by an explicit
// qualifier via SetQualified or implicitly via an attached Table token.
// Nil receiver → false.
//
// Example:
//
//	// No qualifier, no table → false
//	col := NewColumn("id")
//	fmt.Println(col.IsQualified()) // Output: false
//
//	// Explicit qualifier → true
//	col.SetQualified("users")
//	fmt.Println(col.IsQualified()) // Output: true
//
//	// Implicit via table → true
//	col = NewColumn("schema.users.id")
//	fmt.Println(col.IsQualified()) // Output: true
//
// Since: v1.6.0
func (c *Column) IsQualified() bool {
	if c == nil {
		return false
	}
	if c.qualified != "" {
		return true
	}
	if c.Table != nil && (c.Table.IsValid() || c.Table.IsAliased()) {
		return true
	}
	return false
}

// GetRaw returns the SQL-safe, dialect-neutral representation of the column.
//
// The rendering logic adapts based on qualification and aliasing status:
//
//   - If the column is qualified and aliased: it renders as `table_alias.column_alias`
//     This is typical when multiple source tables exist and aliasing prevents ambiguity.
//
//   - If the column is aliased only: it renders as `column_name AS alias`
//     Used for simple renaming in single-table contexts.
//
//   - If the column is qualified only: it renders as `table.column`
//     This is needed for joins or multi-source queries.
//
//   - If the column is neither qualified nor aliased: it renders as `column_name`
//     The simplest fallback for one-source queries.
//
// This behavior allows SelectBuilder to switch between minimal and disambiguated output
// depending on the number of sources involved in the query.
//
// # Examples
//
//	NewColumn("id")                                  	→ "id"
//	NewColumn("id", "alias")                         	→ "id AS alias"
//	NewColumn("users.id")                            	→ "users.id"
//	NewColumn("users.id", "alias")                   	→ "users.id AS alias"
//	NewColumn("id", "alias").WithTable(NewTable("u")) 	→ "u.alias"
func (c *Column) GetRaw() string {
	if c == nil || c.BaseToken == nil {
		return ""
	}

	if c.IsAliased() && c.IsQualified() {
		prefix := c.Table.GetAlias()
		if prefix == "" {
			prefix = c.Table.name
		}
		return fmt.Sprintf("%s.%s", prefix, c.GetAlias())
	}
	if c.IsAliased() {
		return fmt.Sprintf("%s AS %s", c.name, c.GetAlias())
	}
	if c.IsQualified() {
		prefix := c.Table.GetAlias()
		if prefix == "" {
			prefix = c.Table.name
		}
		return fmt.Sprintf("%s.%s", prefix, c.name)
	}
	return c.BaseToken.GetRaw()
}

// Render returns the dialect-aware SQL string for the column,
// using proper quoting for table prefixes and aliasing if applicable.
//
// This method replaces Raw() when generating SQL that must be
// dialect-specific, such as for PostgreSQL, MySQL, or SQLite.
//
// It uses the table alias (if available) for qualified output,
// and falls back to the table name if not.
//
// # Examples
//
//	NewColumn("id").Render(postgres)                   		→ `"id"`
//	NewColumn("id AS uid").Render(postgres)            		→ `"id" AS "uid"`
//	NewColumn("users.id").WithTable(t("users")).Render(postgres) 	→ `"users"."id"`
//	NewColumn("id AS uid").WithTable(t("users u")).Render(postgres)	→ `"u"."id" AS "uid"`
func (c *Column) Render(d driver.Dialect) string {
	if c == nil || !c.IsValid() {
		return ""
	}

	if d == nil {
		d = driver.NewGenericDialect()
	}

	qualified := c.RenderName(d)
	if c.IsQualified() && c.Table != nil {
		base := d.QuoteIdentifier(c.Table.AliasOr())
		if base != "" {
			qualified = fmt.Sprintf("%s.%s", base, qualified)
		}
	}

	if c.IsAliased() {
		qualified = c.RenderAlias(d, qualified)
	}

	return qualified
}

// SetError records a parsing or validation error on the Column’s BaseToken.
// If the Column or its embedded BaseToken is nil, SetError is a no-op.
//
// Example:
//
//	var col *Column = nil
//	col.SetError("expr", fmt.Errorf("something went wrong"))
//	// no panic
//
//	col = NewColumn("users.id")
//	col.SetError("users.id", fmt.Errorf("permission denied"))
//	fmt.Println(col.IsErrored()) // Output: true
//
// Since: v1.6.0
func (c *Column) SetError(input string, err error) {
	if c == nil || c.BaseToken == nil {
		return
	}
	c.BaseToken.SetError(input, err)
}

// SetErrorWith records an error and source expression on the column token.
//
// This method delegates to BaseToken.SetErrorWith and returns the updated *Column,
// enabling fluent usage during parsing or resolution failures.
//
// # Example
//
//	c := NewColumn("id AS uid", "user_id")
//	c.SetErrorWith("id AS uid", fmt.Errorf("alias conflict"))
//	fmt.Println(c.String())
//
//	// Output:
//	Column("id") [aliased: true, qualified: false, errored: true, error: alias conflict]
func (c *Column) SetErrorWith(expr string, err error) *Column {
	if c == nil || c.BaseToken == nil {
		return c
	}

	c.SetError(expr, err)
	return c
}

// SetQualified sets an explicit qualifier for this Column.
// If a qualifier was previously set and the new qualifier differs,
// it records an error rather than overwriting.  Nil receiver → no-op.
//
// Example:
//
//	col := NewColumn("id")
//	col.SetQualified("users")
//	fmt.Println(col.GetQualified()) // Output: users
//
//	// Attempt to override with a different qualifier:
//	col.SetQualified("u")
//	fmt.Println(col.GetQualified()) // Output: users
//	fmt.Println(col.GetError())     // Output includes: qualified conflict: explicit qualifier "u" does not match existing qualifier "users"
//
// Since: v1.6.0
func (c *Column) SetQualified(q string) {
	if c == nil {
		return
	}
	// First time: just set it
	if c.qualified == "" {
		c.qualified = q
		return
	}
	// Already set: if same value, no-op; if different, record conflict
	if c.qualified != q {
		c.SetError(
			c.GetInput(),
			fmt.Errorf(
				"qualified conflict: explicit qualifier %q does not match existing qualifier %q",
				q, c.qualified,
			),
		)
	}
}

// String returns a structured diagnostic view of the column token.
//
// This method reports the internal state of the token using its base name,
// and flags for aliasing, qualification, and error presence.
// It is intended for developer inspection and debugging only.
//
// Unlike Raw(), this output is not suitable for SQL rendering.
//
// # Example Output:
//
//	Column("id") [aliased: false, qualified: false, errored: false]
//	Column("id") [aliased: true, qualified: false, errored: true]
//	Column("m3CUNO") [aliased: true, qualified: true, errored: false]
func (c *Column) String() string {
	if c == nil {
		return "Column(nil)"
	}

	s := fmt.Sprintf("Column(%q) [aliased: %t, qualified: %t, errored: %t]",
		c.name, c.IsAliased(), c.IsQualified(), c.IsErrored(),
	)
	if c.IsErrored() {
		s += fmt.Sprintf(" – %s", c.GetError().Error())
	}
	return s
}

// WithTable attaches a full table token to the column.
//
// This enables alias-aware rendering by giving the column access
// to both the table name and its alias, if present. It also triggers
// column resolution, ensuring consistency between column qualification
// and table context.
//
// # Example
//
//	users := token.NewTable("users AS u")
//	col := token.NewColumn("id", "user_id").WithTable(users)
//	fmt.Println(col.Raw()) // "u.user_id"
func (c *Column) WithTable(table *Table) *Column {
	// nil-safe and error-safe guard
	if c == nil || !c.IsValid() || c.IsErrored() {
		return c
	}

	// If there's a mismatch between expected qualifier and actual table id, error
	if table != nil {
		expected := c.qualified
		// prefer alias, fallback to name
		actual := table.AliasOr()
		if expected != "" && expected != actual {
			c.SetError(c.GetInput(), fmt.Errorf(
				"table mismatch: column refers to %q, but table is %q (alias: %q)",
				expected,
				table.GetName(),
				table.GetAlias(),
			))
			return c
		}

		// otherwise attach the table and update qualifier to actual
		c.Table = table
		c.SetQualified(actual)
	}

	return c
}

// Ensure Column satisfies the GenericToken interface.
var _ GenericToken = &Column{}
var _ contract.MutableToken = &Column{}
var _ contract.Errorable = &Column{}
var _ contract.Kindable = &Column{}
var _ contract.Renderable = &Column{}
var _ contract.Rawable = &Column{}
var _ contract.Qualifiable = &Column{}
