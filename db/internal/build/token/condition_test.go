// Code generated by ENTIQON.
// File: db/internal/build/token/condition.go
// Description: Defines a minimal SQL Condition structure for use in builders.
// Since: v1.6.0

package token_test

import (
	"fmt"
	"strings"
	"testing"

	"github.com/entiqon/db/driver"
	token2 "github.com/entiqon/db/internal/build/token"
)

func TestNewCondition(t *testing.T) {
	d := driver.NewPostgresDialect()

	t.Run("Usage", func(t *testing.T) {
		t.Run("Condition", func(t *testing.T) {
			cond := token2.NewCondition("age", 18)

			if cond.Type != token2.ConditionTypeSimple {
				t.Errorf("expected Type = ConditionTypeSimple, got %v", cond.Type)
			}
			if !cond.IsValid() {
				t.Errorf("expected SIMPLE condition to be valid")
			}
		})

		t.Run("ConditionAnd", func(t *testing.T) {
			cond := token2.NewConditionAnd("age", 18)

			if cond.Type != token2.ConditionTypeAnd {
				t.Errorf("expected Type = ConditionTypeAnd, got %v", cond.Type)
			}
			if !cond.IsValid() {
				t.Errorf("expected AND condition to be valid")
			}
		})

		t.Run("ConditionOr", func(t *testing.T) {
			cond := token2.NewConditionOr("age", 18)

			if cond.Type != token2.ConditionTypeOr {
				t.Errorf("expected Type = ConditionTypeOr, got %v", cond.Type)
			}
			if !cond.IsValid() {
				t.Errorf("expected OR condition to be valid")
			}
		})
	})

	t.Run("Operators", func(t *testing.T) {
		t.Run("Equal", func(t *testing.T) {
			c := token2.NewCondition("status", "active")
			sql, _ := c.Render(d)

			expected := `"status" = $1`
			if sql != expected {
				t.Errorf("Render mismatch: got %q, want %q", sql, expected)
			}
		})

		t.Run("IN", func(t *testing.T) {
			c := token2.NewCondition("type", token2.In, []any{"A", "B"})
			sql, args := c.Render(d)

			if sql != `"type" IN ($1, $2)` {
				t.Errorf("SQL mismatch: got %q, want %q", sql, `"type" IN ($1, $2)`)
			}
			if len(args) != 2 || args[0] != "A" || args[1] != "B" {
				t.Errorf("Args mismatch: got %v", args)
			}
		})

		t.Run("BETWEEN", func(t *testing.T) {
			c := token2.NewCondition("created_at", token2.Between, []any{"2024-01-01", "2024-12-31"})
			sql, args := c.Render(d)

			expected := `"created_at" BETWEEN $1 AND $2`
			if sql != expected {
				t.Errorf("SQL mismatch: got %q, want %q", sql, expected)
			}
			if len(args) != 2 || args[0] != "2024-01-01" || args[1] != "2024-12-31" {
				t.Errorf("Args mismatch: got %v", args)
			}
		})

		t.Run("IS NULL", func(t *testing.T) {
			c := token2.NewConditionWith(token2.ConditionTypeSimple, "deleted_at", token2.IsNull)
			sql, args := c.Render(d)

			expected := `"deleted_at" IS NULL`
			if sql != expected || args != nil {
				t.Errorf("IS NULL mismatch: sql=%q args=%v", sql, args)
			}
		})

		t.Run("IS NOT NULL", func(t *testing.T) {
			c := token2.NewConditionWith(token2.ConditionTypeSimple, "deleted_at", token2.IsNotNull)
			sql, args := c.Render(d)

			expected := `"deleted_at" IS NOT NULL`
			if sql != expected || args != nil {
				t.Errorf("IS NOT NULL mismatch: sql=%q args=%v", sql, args)
			}
		})

		t.Run("FromString", func(t *testing.T) {
			op, err := token2.ParseConditionOperator("=")
			if err != nil || op != token2.Equal {
				t.Errorf("expected Equal, got %q, err=%v", op, err)
			}
		})

		t.Run("FromOperator", func(t *testing.T) {
			op, err := token2.ParseConditionOperator(token2.In)
			if err != nil || op != token2.In {
				t.Errorf("expected In, got %q, err=%v", op, err)
			}
		})

		t.Run("FromBytes", func(t *testing.T) {
			op, err := token2.ParseConditionOperator([]byte(">="))
			if err != nil || op != token2.GreaterThanOrEqual {
				t.Errorf("expected GreaterThanOrEqual, got %q, err=%v", op, err)
			}
		})

		t.Run("InvalidType", func(t *testing.T) {
			_, err := token2.ParseConditionOperator(123)
			if err == nil || !strings.Contains(err.Error(), "unsupported operator type") {
				t.Errorf("expected unsupported type error, got %v", err)
			}
		})
	})

	t.Run("Render", func(t *testing.T) {
		t.Run("NilCondition", func(t *testing.T) {
			var c *token2.Condition
			sql, args := c.Render(d)

			if sql != "" || len(args) != 0 {
				t.Errorf("expected empty sql and args for nil condition, got %q %v", sql, args)
			}
		})

		t.Run("EmptyColumn", func(t *testing.T) {
			c := &token2.Condition{Operator: token2.Equal, Value: "x"}
			sql, args := c.Render(d)

			if sql != "" || len(args) != 0 {
				t.Errorf("expected empty sql and args for missing column, got %q %v", sql, args)
			}
		})

		t.Run("InInvalidType", func(t *testing.T) {
			c := &token2.Condition{Column: token2.NewColumn("role"), Operator: token2.In, Value: "admin"}
			sql, args := c.Render(d)

			if !strings.Contains(sql, "IN ()") || args != nil {
				t.Errorf("expected empty IN list for invalid value, got %q %v", sql, args)
			}
		})

		t.Run("InEmptySlice", func(t *testing.T) {
			c := &token2.Condition{Column: token2.NewColumn("role"), Operator: token2.In, Value: []any{}}
			sql, args := c.Render(d)

			if sql != `"role" IN ()` || args != nil {
				t.Errorf("expected empty IN render, got %q %v", sql, args)
			}
		})

		t.Run("BetweenInvalidType", func(t *testing.T) {
			c := &token2.Condition{Column: token2.NewColumn("created"), Operator: token2.Between, Value: "not a slice"}
			sql, args := c.Render(d)

			if sql != `"created" BETWEEN ? AND ?` || args != nil {
				t.Errorf("expected fallback BETWEEN render, got %q %v", sql, args)
			}
		})

		t.Run("BetweenWrongLength", func(t *testing.T) {
			c := &token2.Condition{Column: token2.NewColumn("created"), Operator: token2.Between, Value: []any{"only-one"}}
			sql, args := c.Render(d)

			if sql != `"created" BETWEEN ? AND ?` || args != nil {
				t.Errorf("expected fallback BETWEEN render with wrong length, got %q %v", sql, args)
			}
		})
	})

	t.Run("String", func(t *testing.T) {
		t.Run("Valid", func(t *testing.T) {
			c := token2.NewCondition("status", token2.Equal, "active")
			str := c.String()

			expected := `Condition("status") [qualified: false, column: true, value: active, errored: false]`
			if str != expected {
				t.Errorf("String() mismatch: got %q, want %q", str, expected)
			}
		})

		t.Run("NilCondition", func(t *testing.T) {
			var c *token2.Condition
			got := c.String()
			want := "Condition(nil)"
			if got != want {
				t.Errorf("expected %q, got %q", want, got)
			}
		})
	})

	t.Run("Validation", func(t *testing.T) {
		t.Run("IsValid", func(t *testing.T) {
			c := token2.NewCondition("status", "active")
			if !c.IsValid() {
				t.Error("expected condition to be valid")
			}
		})

		t.Run("MissingColumn", func(t *testing.T) {
			c := &token2.Condition{
				Operator: token2.Equal,
			}
			if c.IsValid() {
				t.Error("expected condition to be invalid due to missing column definition")
			}
			if c.Error == nil || !strings.Contains(c.Error.Error(), "column definition is required") {
				t.Errorf("unexpected error: %v", c.Error)
			}
		})

		t.Run("EmptyColumn", func(t *testing.T) {
			c := &token2.Condition{}
			sql, args := c.Render(d)
			if sql != "" || len(args) != 0 {
				t.Errorf("Expected empty output for nil condition, got sql=%q args=%v", sql, args)
			}
		})

		t.Run("WithOperatorInvalid", func(t *testing.T) {
			cond := token2.NewCondition("status", "UNKNOWN", "x")

			if cond.IsValid() {
				t.Errorf("expected condition to be invalid due to unrecognized operator string")
			}
		})

		t.Run("TooManyArguments", func(t *testing.T) {
			cond := token2.NewCondition("status", "IN", 1, 2, 3)

			if cond.IsValid() {
				t.Errorf("expected condition to be invalid due to too many arguments")
			}
			if cond.Error == nil || !strings.Contains(cond.Error.Error(), "too many arguments") {
				t.Errorf("expected error about too many arguments, got: %v", cond.Error)
			}
		})

		t.Run("InvalidOperator", func(t *testing.T) {
			c := &token2.Condition{
				Column:   token2.NewColumn("status"),
				Operator: "ðŸ¤¡", // invalid operator
			}
			if c.IsValid() {
				t.Error("expected condition to be invalid due to unsupported operator")
			}
			if c.Error == nil || !strings.Contains(c.Error.Error(), "invalid or unsupported operator") {
				t.Errorf("unexpected error: %v", c.Error)
			}
		})

		t.Run("PreexistingError", func(t *testing.T) {
			c := &token2.Condition{
				Column:   token2.NewColumn("status"),
				Operator: token2.Equal,
				Error:    fmt.Errorf("some prior error"),
			}
			if c.IsValid() {
				t.Error("expected condition to be invalid due to preexisting error")
			}
		})
	})

	t.Run("resolveCondition", func(t *testing.T) {
		c := token2.NewCondition("role", 99, "admin")
		if c.IsValid() {
			t.Error("expected condition to be invalid due to bad operator")
		}
		if c.Error == nil || !strings.Contains(c.Error.Error(), "unsupported operator") {
			t.Errorf("unexpected error: %v", c.Error)
		}
	})
}
