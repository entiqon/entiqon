// Code generated by ENTIQON.
// File: db/internal/core/contracts/qualifiable.go
// Description: Defines the Qualifiable interface for tokens that support explicit qualifiers.
// Since: v1.6.0

package contract

// Qualifiable represents any token that can be “qualified” by a schema or table prefix.
// Use GetQualified and IsQualified to inspect qualification state, and SetQualified
// to override or assign a qualifier.
//
// Example usage with a Column token (which implements Qualifiable):
//
//	func ExampleQualifiable() {
//	    // NewColumn creates a Column wrapping BaseToken.
//	    var q contracts.Qualifiable = token.NewColumn("users.id")
//
//	    // Initially, no explicit qualifier was set.
//	    fmt.Println(q.GetQualified())
//	    // Output:
//
//	    fmt.Println(q.IsQualified())
//	    // Output: false
//
//	    // Explicitly qualify the column (e.g., alias or schema).
//	    q.SetQualified("u")
//	    fmt.Println(q.GetQualified())
//	    // Output: u
//
//	    fmt.Println(q.IsQualified())
//	    // Output: true
//
//	    // Under the hood, Column.IsQualified also checks its attached Table.
//	    q = token.NewColumn("schema.users.id")
//	    fmt.Println(q.GetQualified())
//	    // Output:
//
//	    fmt.Println(q.IsQualified())
//	    // Output: true
//	}
type Qualifiable interface {
	// GetQualified returns the explicit qualifier (e.g., schema, table alias).
	// Nil receiver → empty string.
	GetQualified() string

	// SetQualified overrides the explicit qualifier.
	// Nil receiver → no-op.
	SetQualified(q string)

	// IsQualified reports whether any qualifier is present, either via
	// SetQualified or implicit table attachment. Nil receiver → false.
	IsQualified() bool
}
